use std::str::FromStr;
use crate::ast::*;

grammar;

Comma<T>: Vec<T> = { // (0)
    <mut v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Programm: Vec<AstNode> = {
    <imports:Import*> <statements:Statement*> => imports.into_iter().chain(statements).collect::<Vec<AstNode>>()
};

Import: AstNode = {
    import <module:id> <alias:AliasRule?> semicolon => AstNode::Import(module, alias),
    import native <header:string> <lib:string> <alias:AliasRule?> semicolon => AstNode::ImportNative(header, lib, alias),
};

Statement: AstNode = {
    NonReturnable,
    //Returnable,
    ReturnableStatement,
    If, //Note: das if ist hier nicht zweideutig, wegen dem LR(1)-Lookup von dem Semikolon
    While, 
    For,
};
// nonreturnable: loops, assignments, funcdef, structdef
// returnable: comparison, funccall, math, logic, symbols, constants

ReturnableStatement: AstNode = {
    <Returnable> semicolon
}

Returnable: AstNode = {
    Logic,
};


Logic: AstNode = {
    #[precedence(level="0")]
    Comparison,
    #[precedence(level="1")] #[assoc(side="left")]
    <a:Logic> and <b:Logic> => AstNode::InfixCall(Box::new(a), InfixOperator::And, Box::new(b)),
    #[precedence(level="2")] #[assoc(side="left")]
    <a:Logic> or <b:Logic> => AstNode::InfixCall(Box::new(a), InfixOperator::Or, Box::new(b)),
}

Comparison: AstNode = {
    #[precedence(level="0")]
    Math,
    #[precedence(level="1")] #[assoc(side="left")]
    <a:Comparison> equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::Equals, Box::new(b)),
    <a:Comparison> not_equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::NotEquals, Box::new(b)),
    <a:Comparison> l_angle <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::LessThan, Box::new(b)),
    <a:Comparison> less_equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::LessThanEquals, Box::new(b)),
    <a:Comparison> r_angle <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::GreaterThan, Box::new(b)),
    <a:Comparison> greater_equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::GreaterThanEquals, Box::new(b)),
};

Math: AstNode = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")] #[assoc(side="right")]
    exclamation_mark <Math> => AstNode::PrefixCall(PrefixOperator::Not, Box::new(<>)),
    minus <Math> => AstNode::PrefixCall(PrefixOperator::Negate, Box::new(<>)),
    #[precedence(level="2")] #[assoc(side="left")]
    <a:Math> asterisk <b:Math> => AstNode::InfixCall(Box::new(a), InfixOperator::Multiply, Box::new(b)),
    <a:Math> slash <b:Math> => AstNode::InfixCall(Box::new(a), InfixOperator::Divide, Box::new(b)),
    <a:Math> modulo <b:Math> => AstNode::InfixCall(Box::new(a), InfixOperator::Modulo, Box::new(b)),
    #[precedence(level="3")] #[assoc(side="left")]
    <a:Math> plus <b:Math> => AstNode::InfixCall(Box::new(a), InfixOperator::Plus, Box::new(b)),
    <a:Math> minus <b:Math> => AstNode::InfixCall(Box::new(a), InfixOperator::Minus, Box::new(b)),
}

// if -a {
// }

Term: AstNode = {
    Primitive,
    <s:id> => AstNode::Symbol(s),
    l_paren <Returnable> r_paren,
    Call,
    ListCreate,
    MapCreate,
}

ListCreate: AstNode = {
    l_bracket <elems:Comma<Returnable>> r_bracket => AstNode::List(elems.into_iter().map(|e| Box::new(e)).collect::<Vec<_>>())
}

MapElem: (Box<AstNode>, Box<AstNode>) = {
    <a:Returnable> right_arrow <b:Returnable> => (Box::new(a), Box::new(b)),
}

MapCreate: AstNode = {
    l_brace <mapped:Comma<MapElem>> r_brace => AstNode::Map(mapped),
}

FunctionDefinition: AstNode = {
    fn_term <name:id> l_paren <args:Comma<TypeParamRule>> r_paren <ret:ReturnTypeRule?> l_brace <body:Block> r_brace => AstNode::TypeDef {typename: name, typedef: AstTypeDefinition::Function(args, ret), execution_body: body},
}


Call: AstNode = {
    <function_name:id> l_paren <params:Comma<Returnable>> r_paren => AstNode::FunctionCall{function_name,  params: params.into_iter().map(|p| Box::new(p)).collect::<Vec<_>>()},
    <caller:id> <ma:MemberAccess> => AstNode::MemberCall{parent: caller, calls: ma},
    // <caller:id> dot <method:id> l_paren <params:Comma<Returnable>> r_paren => AstNode::MethodCall{caller, method, params: params.into_iter().map(|p| Box::new(p)).collect::<Vec<_>>()},
}

MemberAccess: Vec<MemberAccess> = { //a.b.c().e
    //<name:id> (l_paren <params:Dot<id>> r_paren
    dot <name:id> <member_access:MemberAccess?> => {
            let mut v = vec![MemberAccess{member: name, params: None}]; 
            if let Some(ma) = member_access {
                v = v.into_iter().chain(ma).collect::<Vec<_>>();
            }
            v
        },
    dot <name:id> l_paren <params:Comma<Returnable>> r_paren <member_access:MemberAccess?> => {
            let mut v = vec![MemberAccess{member: name, params: Some(params.into_iter().map(|p| Box::new(p)).collect::<Vec<_>>())}]; 
            if let Some(ma) = member_access {
                v = v.into_iter().chain(ma).collect::<Vec<_>>();
            }
            v
        }, 
}

StructDefinition: AstNode = {
    struct_term <name:id> l_brace <body:StructBlock> r_brace => AstNode::TypeDef{typename: name, typedef: AstTypeDefinition::Struct(body.attributes), execution_body: body.functions},
}

NonReturnable: AstNode = {
    <AssignmentOrDeclaration> semicolon,
    FunctionDefinition,
    StructDefinition,
};


If: AstNode = {
    if_term <cond:Comparison> l_brace <body:Block> r_brace <elif:ElseIf*> <el:Else?> => AstNode::Branch {cond: Box::new(cond), body, else_if_branches: elif, else_branch: el},
}

ElseIf: (Box<AstNode>, Vec<Box<AstNode>>) = {
    else_term if_term <cond:Comparison> l_brace <body:Block> r_brace => (Box::new(cond), body),
};

Else: Vec<Box<AstNode>> = {
    else_term l_brace <Block> r_brace,
};

While: AstNode = {
    while_term <cond:Comparison> l_brace <body:Block> r_brace => AstNode::While {cond: Box::new(cond), body},
}

For: AstNode = {
    for_term <s:id> in_term <iter:Returnable> l_brace <body:Block> r_brace => AstNode::ForEach {recipient: s, iterable: Box::new(iter), body},
    for_term <d:AssignmentOrDeclaration?> semicolon <cond:Comparison?> semicolon <a:Assignment?> l_brace <body:Block> r_brace => AstNode::For {declaration: d.map(|d| Box::new(d)), condition: cond.map(|cond| Box::new(cond)), assignment: a.map(|a| Box::new(a)), body},
}


ReturnableOrIf: AstNode = {
    Returnable,
    If,
}

Declaration: AstNode = {
    <s:id> declare <e:ReturnableOrIf> => AstNode::Declaration{new_symbol: s, expression: Box::new(e), assumed_type: None},
    let_term <st:TypeParamRule> assign <e:ReturnableOrIf> => AstNode::Declaration{new_symbol: st.0, expression: Box::new(e), assumed_type: Some(st.1)},
}

Assignment: AstNode = {
    <s:id> assign <e:ReturnableOrIf> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Identity, expression: Box::new(e)},
    <s:id> assign_add <e:ReturnableOrIf> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Add, expression: Box::new(e)},
    <s:id> assign_sub <e:ReturnableOrIf> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Subtract, expression: Box::new(e)},
    <s:id> assign_mul <e:ReturnableOrIf> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Multiply, expression: Box::new(e)},
    <s:id> assign_div <e:ReturnableOrIf> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Divide, expression: Box::new(e)},
    <s:id> assign_mod <e:ReturnableOrIf> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Modulo, expression: Box::new(e)},
};

AssignmentOrDeclaration = {
    Declaration,
    Assignment,
}

Block: Vec<Box<AstNode>> = {
    <s:Statement*> => s.into_iter().map(|s| Box::new(s)).collect::<Vec<_>>(),
}



// struct t {
// a: float,
// 
// fn c() {
// }
// 
// b: String,
// }

StructBlock: StructBody = {
    <func:FunctionDefinition> <body:StructBlock?> => if let Some(body) = body {
        StructBody {functions: body.functions.into_iter().chain(vec![Box::new(func)]).collect::<Vec<_>>(), attributes: body.attributes}
    } else {
        StructBody {functions: vec![Box::new(func)], attributes: Vec::new()}
    },
    <attr:TypeParamRule> <body:FurtherStructBlock?> => if let Some(body) = body.flatten() {
        StructBody {functions: body.functions, attributes: body.attributes.into_iter().chain(vec![attr]).collect::<Vec<_>>()}
    } else {
        StructBody {functions: Vec::new(), attributes: vec![attr]}
    },
}

FurtherStructBlock: Option<StructBody> = {
    "," <StructBlock> => Some(<>),
    "," => None,
}


ReturnType: TypeSymbol = {
    #[precedence(level="0")]
    <t:id> => TypeSymbol::strong(TypeSymbolType::Symbol(t)),
    <r:ReturnType> l_bracket r_bracket => TypeSymbol::strong(TypeSymbolType::List(Box::new(r))),
    l_brace <a:ReturnType> right_arrow <b:ReturnType> r_brace => TypeSymbol::strong(TypeSymbolType::Map(Box::new(a), Box::new(b))),
    #[precedence(level="1")] #[assoc(side="right")]
    weak_term <t:ReturnType> => TypeSymbol::make_weak(t),
    // TODO: This is still broken, figure out how to match weak weak T[], or similar
}


ReturnTypeRule: TypeSymbol = {
    colon <t:ReturnType> => t,
};
TypeParamRule: (Symbol, TypeSymbol) = {
    id ReturnTypeRule,
};

AliasRule: Alias = {
    as_term <id>,
};

Primitive: AstNode = {
    <i:int> => AstNode::Int(i),
    <f:float> => AstNode::Float(f),
    <s:string> => AstNode::String(s),
    <b:Bool> => AstNode::Bool(b),
}

Bool: bool = {
    bool_true => true,
    bool_false => false,
};

// Datatypes
int: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
};
float: f64 = {
    r"[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap()
};
bool_true: bool = {
    "true" => true
};
bool_false: bool = {
    "false" => false 
};

string: String = {
    // https://stackoverflow.com/a/47214303
    <s:r#""([^"][\x00-\x7f])*""#> => s.to_owned()
};

id: String = {
    <s:r"[a-zA-Z][a-zA-Z_0-9]*"> => s.to_owned()
};

// Terminal Symbols
l_paren: () = {
    "(" => ()
};
r_paren: () = {
    ")" => ()
};
l_bracket: () = {
    "[" => ()
};
r_bracket: ()= {
    "]" => ()
};
l_brace: () = {
    "{" => ()
};
r_brace: ()= {
    "}" => ()
};
l_angle: () = {
    "<" => ()
};
r_angle: ()= {
    ">" => ()
};
plus: () = {
    "+" => ()
};
minus: () = {
    "-" => ()
};
asterisk: () = {
    "*" => ()
};
slash: () = {
    "/" => ()
};
modulo: () = {
    "%" => ()
};
less_equals: () = {
    "<=" => ()
};
greater_equals: () = {
    ">=" => ()
};
equals: () = {
    "==" => ()
};
not_equals: () = {
    "!=" => ()
};
assign: () = {
    "=" => ()
};
assign_add: () = {
    "+=" => ()
};
assign_sub: () = {
    "-=" => ()
};
assign_mul: () = {
    "*=" => ()
};
assign_div: () = {
    "/=" => ()
};
assign_mod: () = {
    "%=" => ()
};
declare: () = {
    ":=" => ()
};
slash_term: () = {
    "/" => ()
};
and: () = {
    "&&" => ()
}
or: () = {
    "||" => ()
}
right_arrow: () = {
    "->" => ()
};
fn_term: () = {
    "fn" => ()
};
struct_term: () = {
    "struct" => ()
}
let_term: () = {
    "let" => ()
};
while_term: () = {
    "while" => ()
};
for_term: () = {
    "for" => ()
};
in_term: () = {
    "in" => ()
}
if_term: () = {
    "if" => ()
};
else_term: () = {
    "else" => ()
};
return: () = {
    "return" => ()
};
with: () = {
    "with" => ()
};
default: () = {
    "default" => ()
};
import: () = {
    "import" => ()
};
native: () = {
    "native" => ()
};
as_term: () = {
    "as" => ()
};
ffi: () = {
    "ffi" => ()
};
arrow: () = {
    "->" => ()
};
semicolon: () = {
    ";" => ()
};
colon: () = {
    ":" => ()
};
dot: () = {
    "." => ()
}
exclamation_mark: () =Â {
    "!" => ()
}
weak_term: () = {
    "weak" => ()
}

// pub Expr: Box<Expr> = {
//     #[precedence(level="0")]
//     Term,
//     #[precedence(level="1")] #[assoc(side="left")]
//     Expr FactorOp Expr => Box::new(Expr::Op(<>)),
//     #[precedence(level="2")] #[assoc(side="left")]
//     Expr ExprOp Expr => Box::new(Expr::Op(<>)),
// };
//
// ExprOp: OpCode = {
//     "+" => OpCode::Add,
//     "-" => OpCode::Sub,
// };
//
// FactorOp: OpCode = {
//     "*" => OpCode::Mul,
//     "/" => OpCode::Div,
// };
//
// Term: Box<Expr> = {
//     Num => Box::new(Expr::Number(<>)), // (4)
//     "(" <Expr> ")"
// };
//
// Num: i32 = {
//     r"[0-9]+" => i32::from_str(<>).unwrap()
// };
