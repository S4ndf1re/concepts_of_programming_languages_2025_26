use std::str::FromStr;
use crate::ast::*;

grammar;

Comma<T>: Vec<T> = { // (0)
    <mut v:(<T> ",")*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

pub Programm: Vec<AstNode> = {
    <imports:Import*> <statements:Statement*> => imports.into_iter().chain(statements).collect::<Vec<AstNode>>()
};

Import: AstNode = {
    import <module:id> <alias:AliasRule?> semicolon => AstNode::Import(module, alias),
    import native <header:string> <lib:string> <alias:AliasRule?> semicolon => AstNode::ImportNative(header, lib, alias),
};

Statement: AstNode = {
    NonReturnable,
    //Returnable,
    ReturnableStatement,
    If, //Note: das if ist hier nicht zweideutig, wegen dem LR(1)-Lookup von dem Semikolon
    While, 
    For,
};
// nonreturnable: loops, assignments, funcdef, structdef
// returnable: comparison, funccall, math, logic, symbols, constants

ReturnableStatement: AstNode = {
    <Returnable> semicolon
}

Returnable: AstNode = {
    Comparison,
};

Term: AstNode = {
    If,
    Primitive,
    <s:id> => AstNode::Symbol(s),
    <caller:id> dot <method:id> l_paren <params:Comma<Returnable>> r_paren => AstNode::MethodCall{caller, method, params: params.into_iter().map(|p| Box::new(p)).collect::<Vec<_>>()},
    l_paren <Returnable> r_paren,
}

Comparison: AstNode = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")] #[assoc(side="left")]
    <a:Comparison> equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::Equals, Box::new(b)),
    <a:Comparison> not_equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::NotEquals, Box::new(b)),
    <a:Comparison> l_angle <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::LessThan, Box::new(b)),
    <a:Comparison> less_equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::LessThanEquals, Box::new(b)),
    <a:Comparison> r_angle <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::GreaterThan, Box::new(b)),
    <a:Comparison> greater_equals <b:Comparison> => AstNode::InfixCall(Box::new(a), InfixOperator::GreaterThanEquals, Box::new(b)),
};

NonReturnable: AstNode = {
    <AssignmentOrDeclaration> semicolon,
    fn_term <name:id> l_paren <args:Comma<TypeParamRule>> r_paren <ret:ReturnTypeRule?> l_brace <body:Block> r_brace => AstNode::TypeDef {typename: name, typedef: AstTypeDefinition::Function(args, ret), execution_body: body},
};

Block: Vec<Box<AstNode>> = {
    <s:Statement*> => s.into_iter().map(|s| Box::new(s)).collect::<Vec<_>>(),
}

If: AstNode = {
    if_term <cond:Comparison> l_brace <body:Block> r_brace <elif:ElseIf*> <el:Else?> => AstNode::Branch {cond: Box::new(cond), body, else_if_branches: elif, else_branch: el},
}

ElseIf: (Box<AstNode>, Vec<Box<AstNode>>) = {
    else_term if_term <cond:Comparison> l_brace <body:Block> r_brace => (Box::new(cond), body),
};

Else: Vec<Box<AstNode>> = {
    else_term l_brace <Block> r_brace,
};

While: AstNode = {
    while_term <cond:Comparison> l_brace <body:Block> r_brace => AstNode::While {cond: Box::new(cond), body},
}

For: AstNode = {
    for_term <s:id> in_term <iter:Returnable> l_brace <body:Block> r_brace => AstNode::ForEach {recipient: s, iterable: Box::new(iter), body},
    for_term <d:AssignmentOrDeclaration?> semicolon <cond:Comparison?> semicolon <a:Assignment?> l_brace <body:Block> r_brace => AstNode::For {declaration: d.map(|d| Box::new(d)), condition: cond.map(|cond| Box::new(cond)), assignment: a.map(|a| Box::new(a)), body},
}

Declaration: AstNode = {
    <s:id> declare <e:Returnable> => AstNode::Declaration{new_symbol: s, expression: Box::new(e), assumed_type: None},
    let_term <st:TypeParamRule> assign <e:Returnable> => AstNode::Declaration{new_symbol: st.0, expression: Box::new(e), assumed_type: Some(st.1)},
}

Assignment: AstNode = {
    <s:id> assign <e:Returnable> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Identity, expression: Box::new(e)},
    <s:id> assign_add <e:Returnable> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Add, expression: Box::new(e)},
    <s:id> assign_sub <e:Returnable> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Subtract, expression: Box::new(e)},
    <s:id> assign_mul <e:Returnable> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Multiply, expression: Box::new(e)},
    <s:id> assign_div <e:Returnable> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Divide, expression: Box::new(e)},
    <s:id> assign_mod <e:Returnable> => AstNode::AssignmentOp{recipient: s, operation: AssignmentOperations::Modulo, expression: Box::new(e)},
};

AssignmentOrDeclaration = {
    Declaration,
    Assignment,
}

ReturnTypeRule: TypeSymbol = {
    colon <t:id> => TypeSymbol::new(t)
};
TypeParamRule: (Symbol, TypeSymbol) = {
    id ReturnTypeRule,
};

AliasRule: Alias = {
    as_term <id>,
};

Primitive: AstNode = {
    <i:int> => AstNode::Int(i),
    <f:float> => AstNode::Float(f),
    <s:string> => AstNode::String(s),
    <b:Bool> => AstNode::Bool(b),
}

Bool: bool = {
    bool_true => true,
    bool_false => false,
};

// Datatypes
int: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
};
float: f64 = {
    r"[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap()
};
bool_true: bool = {
    "true" => true
};
bool_false: bool = {
    "false" => false 
};

string: String = {
    // https://stackoverflow.com/a/47214303
    <s:r#""([^"][\x00-\x7f])*""#> => s.to_owned()
};

id: String = {
    <s:r"[a-zA-Z][a-zA-Z_0-9]*"> => s.to_owned()
};

// Terminal Symbols
l_paren: () = {
    "(" => ()
};
r_paren: () = {
    ")" => ()
};
l_bracket: () = {
    "[" => ()
};
r_bracket: ()= {
    "[" => ()
};
l_brace: () = {
    "{" => ()
};
r_brace: ()= {
    "}" => ()
};
l_angle: () = {
    "<" => ()
};
r_angle: ()= {
    ">" => ()
};
plus: () = {
    "+" => ()
};
minus: () = {
    "-" => ()
};
asterisk: () = {
    "*" => ()
};
slash: () = {
    "/" => ()
};
less_equals: () = {
    "<=" => ()
};
greater_equals: () = {
    ">=" => ()
};
equals: () = {
    "==" => ()
};
not_equals: () = {
    "!=" => ()
};
assign: () = {
    "=" => ()
};
assign_add: () = {
    "+=" => ()
};
assign_sub: () = {
    "-=" => ()
};
assign_mul: () = {
    "*=" => ()
};
assign_div: () = {
    "/=" => ()
};
assign_mod: () = {
    "%=" => ()
};
declare: () = {
    ":=" => ()
};
slash_term: () = {
    "/" => ()
};
and: () = {
    "&&" => ()
}
or: () = {
    "||" => ()
}
right_arrow: () = {
    "->" => ()
};
fn_term: () = {
    "fn" => ()
};
let_term: () = {
    "let" => ()
};
while_term: () = {
    "while" => ()
};
for_term: () = {
    "for" => ()
};
in_term: () = {
    "in" => ()
}
if_term: () = {
    "if" => ()
};
else_term: () = {
    "else" => ()
};
return: () = {
    "return" => ()
};
with: () = {
    "with" => ()
};
default: () = {
    "default" => ()
};
import: () = {
    "import" => ()
};
native: () = {
    "native" => ()
};
as_term: () = {
    "as" => ()
};
ffi: () = {
    "ffi" => ()
};
arrow: () = {
    "->" => ()
};
semicolon: () = {
    ";" => ()
};
colon: () = {
    ":" => ()
};
dot: () = {
    "." => ()
}

// pub Expr: Box<Expr> = {
//     #[precedence(level="0")]
//     Term,
//     #[precedence(level="1")] #[assoc(side="left")]
//     Expr FactorOp Expr => Box::new(Expr::Op(<>)),
//     #[precedence(level="2")] #[assoc(side="left")]
//     Expr ExprOp Expr => Box::new(Expr::Op(<>)),
// };
//
// ExprOp: OpCode = {
//     "+" => OpCode::Add,
//     "-" => OpCode::Sub,
// };
//
// FactorOp: OpCode = {
//     "*" => OpCode::Mul,
//     "/" => OpCode::Div,
// };
//
// Term: Box<Expr> = {
//     Num => Box::new(Expr::Number(<>)), // (4)
//     "(" <Expr> ")"
// };
//
// Num: i32 = {
//     r"[0-9]+" => i32::from_str(<>).unwrap()
// };
