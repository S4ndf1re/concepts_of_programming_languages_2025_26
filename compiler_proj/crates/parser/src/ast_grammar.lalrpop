use std::str::FromStr;
use crate::ast::*;
use crate::typed::*;

grammar;

match {
    r"\s*" => { },
    r"\/\/[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"[0-9]+" => INT,
    r"[0-9]+\.[0-9]+" => FLOAT,
    "true" => BOOLTRUE,
    "false" => BOOLFALSE,
    r#""(\\\\|\\"|\\n|\\t|\\r|[^"\\])*""# => STRING,
    r"[a-zA-Z][a-zA-Z_0-9]*" => ID,
    "(" => l_paren,
    ")" => r_paren,
    "[" => l_bracket,
    "]" => r_bracket,
    "{" => l_brace,
    "}" => r_brace,
    "<" => l_angle,
    ">" => r_angle,
    "+" => plus,
    "-" => minus,
    "*" => asterisk,
    "/" => slash,
    "%" => modulo,
    "<=" => less_equals,
    ">=" => greater_equals,
    "==" => equals,
    "!=" => not_equals,
    "=" => assign,
    "+=" => assign_add,
    "-=" => assign_sub,
    "*=" => assign_mul,
    "/=" => assign_div,
    "%=" => assign_mod,
    ":=" => declare,
    "&&" => and,
    "||" => or,
    "->" => right_arrow,
    "fn" => fn_term,
    "struct" => struct_term,
    "let" => let_term,
    "while" => while_term,
    "for" => for_term,
    "in" => in_term,
    "if" => if_term,
    "else" => else_term,
    "return" => return,
    "with" => with,
    "default" => default,
    "import" => import,
    "native" => native,
    "as" => as_term,
    "ffi" => ffi,
    ";" => semicolon,
    ":" => colon,
    "." => dot,
    "," => comma,
    "!" => exclamation_mark,
    "?" => question_mark,
    "weak" => weak_term,
    "none" => none_term,
    "some" => some_term,
    "ok" => ok_term,
    "err" => err_term,
    "self" => self_term,
}

/// Matches a or 1,...,n meaning any comma separated list
Comma<T>: Vec<T> = { // (0)
    <mut v:(<T> comma)*> <e:T?> => match e { // (1)
        None=> v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

/// Start point of the grammar
pub Programm: Vec<AstNode> = {
    <imports:Import*> <statements:Statement*> => imports.into_iter().chain(statements).collect::<Vec<AstNode>>()
};

/// Any import, i.e. native ffi import and normal 
Import: AstNode = {
    <l:@L> import <module:id> <alias:AliasRule?> semicolon <r:@R> => AstNode::new(l..r, AstNodeType::Import(module, alias)),
    <l:@L> import native <header:string> <lib:string> <alias:AliasRule?> semicolon <r:@R> => AstNode::new(l..r, AstNodeType::ImportNative(header, lib, alias)),
};

/// Any statement, meaning if, while, for, anything non returnable like function definitions, struct definitions and assignments. Additionally Returnable statements with semicolon
Statement: AstNode = {
    NonReturnable,
    ReturnableStatement,
    If, //Note: das if ist hier nicht zweideutig, wegen dem LR(1)-Lookup von dem Semikolon
    While,
    For,
};

/// Anything that may return a value, but with a trailing semicolon
ReturnableStatement: AstNode = {
    <Returnable> semicolon,

}

/// Anything returnable, like function calls, symbols (return themselves) and primities
Returnable: AstNode = {
    Logic,
};


/// Any logic operation, i.e. a && b || c
Logic: AstNode = {
    #[precedence(level="0")]
    Comparison,
    #[precedence(level="1")] #[assoc(side="left")]
    <l:@L> <a:Logic> and <b:Logic> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::And, Box::new(b))),
    #[precedence(level="2")] #[assoc(side="left")]
    <l:@L> <a:Logic> or <b:Logic> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::Or, Box::new(b))),
}

/// Any comparison like a == b , b < c
Comparison: AstNode = {
    #[precedence(level="0")]
    Math,
    #[precedence(level="1")] #[assoc(side="left")]
    <l: @L> <a:Comparison> equals <b:Comparison> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::Equals, Box::new(b))),
    <l: @L> <a:Comparison> not_equals <b:Comparison> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::NotEquals, Box::new(b))),
    <l: @L> <a:Comparison> l_angle <b:Comparison> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::LessThan, Box::new(b))),
    <l: @L> <a:Comparison> less_equals <b:Comparison> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::LessThanEquals, Box::new(b))),
    <l: @L> <a:Comparison> r_angle <b:Comparison> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::GreaterThan, Box::new(b))),
    <l: @L> <a:Comparison> greater_equals <b:Comparison> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::GreaterThanEquals, Box::new(b))),
}

/// Any math operation like a + b * c, additionally, unary operators like !a und -a are supported here
Math: AstNode = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")] #[assoc(side="right")] // Unary
    <l:@L> exclamation_mark <m:Math> <r:@R> => AstNode::new(l..r, AstNodeType::PrefixCall(PrefixOperator::Not, Box::new(m))),
    <l:@L> minus <m:Math> <r:@R> => AstNode::new(l..r, AstNodeType::PrefixCall(PrefixOperator::Negate, Box::new(m))),
    #[precedence(level="2")] #[assoc(side="left")] // Infix
    <l:@L> <a:Math> asterisk <b:Math> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::Multiply, Box::new(b))),
    <l:@L> <a:Math> slash <b:Math> <r:@R> =>    AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::Divide, Box::new(b))),
    <l:@L> <a:Math> modulo <b:Math> <r:@R> =>   AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::Modulo, Box::new(b))),
    #[precedence(level="3")] #[assoc(side="left")]
    <l:@L> <a:Math> plus <b:Math> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::Plus, Box::new(b))),
    <l:@L> <a:Math> minus <b:Math> <r:@R> => AstNode::new(l..r, AstNodeType::InfixCall(Box::new(a), InfixOperator::Minus, Box::new(b))),
}


Id: AstNode = {
    <l:@L> <s:id> <r:@R> => AstNode::new(l..r, AstNodeType::Symbol(s)),
}

/// Anything that is returnable. Is used in all logic and math rules
Term: AstNode = {
    Primitive,
    Id,
    l_paren <Returnable> r_paren,
    Call,
    ListCreate,
    MapCreate,
    OptionCreate,
    ResultCreate,
}

/// Creates some(v) or none as an option
OptionCreate: AstNode = {
    <l:@L> none_term <r:@R> => AstNode::new(l..r, AstNodeType::Option(None)),
    <l:@L> some_term l_paren <v:Returnable> r_paren <r:@R> => AstNode::new(l..r, AstNodeType::Option(Some(Box::new(v)))),
}

/// Creates ok(v) or err(v) as a result
ResultCreate: AstNode = {
    <l:@L> err_term l_paren <e:Returnable> r_paren <r:@R> => AstNode::new(l..r, AstNodeType::Result(Err(Box::new(e)))),
    <l:@L> ok_term l_paren <v:Returnable> r_paren <r:@R> => AstNode::new(l..r, AstNodeType::Result(Ok(Box::new(v)))),
}

/// Creates [a,b,c, ...] as a list ([] also supported)
ListCreate: AstNode = {
    <l:@L> l_bracket <elems:Comma<Returnable>> r_bracket <r:@R> => AstNode::new(l..r, AstNodeType::List(elems.into_iter().map(|e| Box::new(e)).collect::<Vec<_>>()))
}

/// Creates {a -> b, b -> c} as a map
MapElem: (Box<AstNode>, Box<AstNode>) = {
    <a:Returnable> right_arrow <b:Returnable> => (Box::new(a), Box::new(b)),
}

MapCreate: AstNode = {
    <l:@L> l_brace <mapped:Comma<MapElem>> r_brace <r:@R> => AstNode::new(l..r, AstNodeType::Map(mapped)),
}

/// Creates s {a: 10, b: ""} as a struct. Nested structs are also supported
StructCreate: AstNode = {
    <l:@L> <sname:id> l_brace <p:StructAssignmentList?> r_brace <r:@R> => AstNode::new(l..r, AstNodeType::StructInitializer{name: sname, values: p.unwrap_or_default()})
}

StructAssignmentList: Vec<(Symbol, Box<AstNode>)> = {
    <p:StructParamRule> <n:FurtherStructAssignment> => vec![p].into_iter().chain(n).collect::<Vec<_>>(),
}

FurtherStructAssignment: Vec<(Symbol, Box<AstNode>)> = {
    comma <StructAssignmentList>,
    comma => vec![],
}


/// Defines any function
FunctionDefinition: AstNode = {
    <l:@L> fn_term <name:id> l_paren <args:Comma<TypeParamRule>> r_paren <ret:ReturnTypeRule?> l_brace <body:Block> r_brace <r:@R> => AstNode::new(l..r, AstNodeType::TypeDef {typename: name, typedef: AstTypeDefinition::Function(args, ret), execution_body: body}),
}

/// call any function or method, using chained member access, i.e. a.b().c.d()
Call: AstNode = {
    <l:@L> <function_name:id> l_paren <params:Comma<Returnable>> r_paren <r:@R> => AstNode::new(l..r, AstNodeType::FunctionCall{function_name,  params: params.into_iter().map(|p| Box::new(p)).collect::<Vec<_>>()}),
    <l:@L> <caller:id> <ma:MemberAccess> <r:@R> => AstNode::new(l..r, AstNodeType::MemberCall{parent: caller, calls: ma}),
    // <caller:id> dot <method:id> l_paren <params:Comma<Returnable>> r_paren => AstNode::MethodCall{caller, method, params: params.into_iter().map(|p| Box::new(p)).collect::<Vec<_>>()},
}

MemberAccess: Vec<MemberAccess> = { //a.b.c().e
    //<name:id> (l_paren <params:Dot<id>> r_paren
    <l:@L> dot <name:id> <r:@R> <member_access:MemberAccess?> => {
            let mut v = vec![MemberAccess{member: name, params: None, range: l..r}];
            if let Some(ma) = member_access {
                v = v.into_iter().chain(ma).collect::<Vec<_>>();
            }
            v
        },
    <l:@L> dot <name:id> l_paren <params:Comma<Returnable>> r_paren <r:@R> <member_access:MemberAccess?> => {
            let mut v = vec![MemberAccess{member: name, params: Some(params.into_iter().map(|p| Box::new(p)).collect::<Vec<_>>()), range: l..r}];
            if let Some(ma) = member_access {
                v = v.into_iter().chain(ma).collect::<Vec<_>>();
            }
            v
        },
}

/// Any struct definition s {a: float, b: int, fn abc() {} }
StructDefinition: AstNode = {
    <l:@L> struct_term <name:id> l_brace <body:StructBlock> r_brace <r:@R> => AstNode::new(l..r, AstNodeType::TypeDef{typename: name, typedef: AstTypeDefinition::Struct(body.attributes), execution_body: body.functions}),
}

/// Anything that may not return, i.e. struct and function definitions, inclusive assignments
NonReturnable: AstNode = {
    <AssignmentOrDeclaration> semicolon,
    FunctionDefinition,
    StructDefinition,
    <l:@L> return <a:ReturnableOrIfOrStruct> semicolon <r:@R>=> AstNode::new(l..r, AstNodeType::ReturnStatement{return_value: Box::new(a)}),
};


If: AstNode = {
    <l:@L> if_term <cond:Comparison> l_brace <body:Block> r_brace <elif:ElseIf*> <el:Else?> <r:@R> => AstNode::new(l..r, AstNodeType::Branch {cond: Box::new(cond), body, else_if_branches: elif, else_branch: el}),
}

ElseIf: (Box<AstNode>, Vec<Box<AstNode>>) = {
    else_term if_term <cond:Comparison> l_brace <body:Block> r_brace => (Box::new(cond), body),
}

Else: Vec<Box<AstNode>> = {
    else_term l_brace <Block> r_brace,
}

While: AstNode = {
    <l:@L> while_term <cond:Comparison> l_brace <body:Block> r_brace <r:@R> => AstNode::new(l..r, AstNodeType::While {cond: Box::new(cond), body}),
}

For: AstNode = {
    <l:@L> for_term <s:id> in_term <iter:Returnable> l_brace <body:Block> r_brace <r:@R> => AstNode::new(l..r, AstNodeType::ForEach {recipient: s, iterable: Box::new(iter), body}),
    <l:@L> for_term <d:ForAssignmentOrDeclaration?> semicolon <cond:Comparison?> semicolon <a:ForAssignment?> l_brace <body:Block> r_brace <r:@R> => AstNode::new(l..r, AstNodeType::For {declaration: d.map(|d| Box::new(d)), condition: cond.map(|cond| Box::new(cond)), assignment: a.map(|a| Box::new(a)), body}),
}


/// Special rule for any returnable or if. For assignments, if may return a value, hence it is returnable for a single rule context
ReturnableOrIfOrStruct: AstNode = {
    Returnable,
    If,
    StructCreate,
}

ReturnableOrIf: AstNode = {
    Returnable,
    If,
}

/// let a = b; or a := b;
Declaration: AstNode = {
    <l:@L> <s:id> declare <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::Declaration{new_symbol: s, expression: Box::new(e), assumed_type: None}),
    <l:@L> let_term <st:TypeParamRule> assign <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::Declaration{new_symbol: st.0, expression: Box::new(e), assumed_type: Some(st.1)}),
}

ForDeclaration: AstNode = {
    <l:@L> <s:id> declare <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::Declaration{new_symbol: s, expression: Box::new(e), assumed_type: None}),
    <l:@L> let_term <st:TypeParamRule> assign <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::Declaration{new_symbol: st.0, expression: Box::new(e), assumed_type: Some(st.1)}),
}

/// a = b; also a += b; a -= b; etc.
Assignment: AstNode = {
    <l:@L> <s:id> assign     <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Identity, expression: Box::new(e)}),
    <l:@L> <s:id> assign_add <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Add, expression: Box::new(e)}),
    <l:@L> <s:id> assign_sub <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Subtract, expression: Box::new(e)}),
    <l:@L> <s:id> assign_mul <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Multiply, expression: Box::new(e)}),
    <l:@L> <s:id> assign_div <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Divide, expression: Box::new(e)}),
    <l:@L> <s:id> assign_mod <e:ReturnableOrIfOrStruct> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Modulo, expression: Box::new(e)}),
}

ForAssignment: AstNode = {
    <l:@L> <s:id> assign     <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Identity, expression: Box::new(e)}),
    <l:@L> <s:id> assign_add <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Add, expression: Box::new(e)}),
    <l:@L> <s:id> assign_sub <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Subtract, expression: Box::new(e)}),
    <l:@L> <s:id> assign_mul <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Multiply, expression: Box::new(e)}),
    <l:@L> <s:id> assign_div <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Divide, expression: Box::new(e)}),
    <l:@L> <s:id> assign_mod <e:ReturnableOrIf> <r:@R> => AstNode::new(l..r, AstNodeType::AssignmentOp{recipient: s, operation: AssignmentOperations::Modulo, expression: Box::new(e)}),
}

ForAssignmentOrDeclaration = {
    ForDeclaration,
    ForAssignment,
}

AssignmentOrDeclaration = {
    Declaration,
    Assignment,
}

/// Any block of a list of statements, primarily used in functions, loops and if branches
Block: Vec<Box<AstNode>> = {
    <s:Statement*> => s.into_iter().map(|s| Box::new(s)).collect::<Vec<_>>(),
}


/// A block specifically for struct definitions
StructBlock: StructBody = {
    <func:FunctionDefinition> <body:StructBlock?> => if let Some(body) = body {
        StructBody {functions: body.functions.into_iter().chain(vec![Box::new(func)]).collect::<Vec<_>>(), attributes: body.attributes}
    } else {
        StructBody {functions: vec![Box::new(func)], attributes: Vec::new()}
    },
    <attr:TypeParamRule> <body:FurtherStructBlock?> => if let Some(body) = body.flatten() {
        StructBody {functions: body.functions, attributes: body.attributes.into_iter().chain(vec![attr]).collect::<Vec<_>>()}
    } else {
        StructBody {functions: Vec::new(), attributes: vec![attr]}
    },
}

FurtherStructBlock: Option<StructBody> = {
    comma <StructBlock> => Some(<>),
    comma => None,
}


/// a Type definition. Can be weak. Is only combined within the returnTypeRule. 
ReturnType: TypeSymbol = {
    #[precedence(level="0")]
    <t:id> => TypeSymbol::strong(TypeSymbolType::Symbol(t)),
    l_bracket <r:ReturnType> r_bracket => TypeSymbol::strong(TypeSymbolType::List(Box::new(r))),
    l_brace <a:ReturnType> right_arrow <b:ReturnType> r_brace => TypeSymbol::strong(TypeSymbolType::Map(Box::new(a), Box::new(b))),
    weak_term <t:ReturnType> => TypeSymbol::make_weak(t),

    #[precedence(level="1")] #[assoc(side="left")]
    <a:ReturnType> question_mark => TypeSymbol::strong(TypeSymbolType::Option(Box::new(a))),
    <a:ReturnType> exclamation_mark <b:ReturnType> => TypeSymbol::strong(TypeSymbolType::Result(Box::new(a), Box::new(b))),
}


/// Any return type
ReturnTypeRule: TypeSymbol = {
    colon <t:ReturnType> => t,
}

TypeParamRule: (Symbol, TypeSymbol) = {
    id ReturnTypeRule,
    self_term => ("self".to_owned(), TypeSymbol::strong(TypeSymbolType::SelfType)),
    weak_term self_term => ("self".to_owned(), TypeSymbol::weak(TypeSymbolType::SelfType)),
}

StructParamRule: (Symbol, Box<AstNode>) = {
    <n:id> colon <v:ReturnableOrIfOrStruct> => (n, Box::new(v))
}

AliasRule: Alias = {
    as_term <id>,
}

Primitive: AstNode = {
    <l:@L> <i:int>     <r:@R> => AstNode::new(l..r, AstNodeType::Int(i)),
    <l:@L> <f:float>   <r:@R> => AstNode::new(l..r, AstNodeType::Float(f)),
    <l:@L> <s:string>  <r:@R> => AstNode::new(l..r, AstNodeType::String(s)),
    <l:@L> <b:Bool>    <r:@R> => AstNode::new(l..r, AstNodeType::Bool(b)),
}

Bool: bool = {
    bool_true => true,
    bool_false => false,
}


// Datatypes
int: i64 = {
    INT => i64::from_str(<>).unwrap()
}
float: f64 = {
    FLOAT => f64::from_str(<>).unwrap()
}
bool_true: bool = {
    BOOLTRUE => true
}
bool_false: bool = {
    BOOLFALSE => false
}

string: String = {
    <s:STRING> => apply_string_escapes(&s[1..s.len()-1]),
}

id: String = {
    <s:ID> => s.to_owned()
}

